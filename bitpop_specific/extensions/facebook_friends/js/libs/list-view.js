// Generated by CoffeeScript 1.7.1
var Emberella, root, _ref;

root = window;

Emberella = root.Emberella = Ember.Namespace.create();

Emberella.VERSION = '0.0.1';

if ((_ref = Ember.libraries) != null) {
  _ref.register('Emberella', Emberella.VERSION);
}

// Generated by CoffeeScript 1.7.1
Emberella.BaseViewMixin = Ember.Mixin.create({
  baseViewBinding: 'parentView.baseView',
  init: function() {
    this._super();
    return this.set('_self', this);
  }
});

Emberella.View = Ember.View.extend(Emberella.BaseViewMixin);

Emberella.ContainerView = Ember.ContainerView.extend(Emberella.BaseViewMixin);

Emberella.CollectionView = Ember.CollectionView.extend(Emberella.BaseViewMixin);

// Generated by CoffeeScript 1.7.1
var Emberella;

Emberella = window.Emberella;

Emberella.throttle = function(func, wait) {
  var args, context, later, previous, result, timeout;
  context = null;
  args = null;
  timeout = null;
  result = null;
  previous = 0;
  later = function() {
    previous = new Date();
    timeout = null;
    return result = func.apply(context, args);
  };
  return function() {
    var now, remaining;
    now = new Date();
    remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0) {
      clearTimeout(timeout);
      timeout = null;
      previous = now;
      result = func.apply(context, args);
    } else {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
};

Emberella.debounce = function(func, wait, immediate) {
  var result, timeout;
  timeout = null;
  result = null;
  return function() {
    var args, callNow, context, later;
    context = this;
    args = arguments;
    later = function() {
      timeout = null;
      if (!immediate) {
        return result = func.apply(context, args);
      }
    };
    callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
    }
    return result;
  };
};

// Generated by CoffeeScript 1.7.1
var $, Emberella, jQuery;

jQuery = window.jQuery;

if (!$) {
  $ = jQuery;
}

Ember.ResizeHandler = Ember.Mixin.create({
  resizeEndDelay: 100,
  resizing: false,
  onResizeStart: Ember.K,
  onResizeEnd: Ember.K,
  onResize: Ember.K,
  debounceResizeEnd: Ember.computed(function() {
    return Emberella.debounce((function(_this) {
      return function(event) {
        if (_this.isDestroyed) {
          return;
        }
        _this.set('resizing', false);
        return typeof _this.onResizeEnd === "function" ? _this.onResizeEnd(event) : void 0;
      };
    })(this), this.get('resizeEndDelay'));
  }).property('resizeEndDelay'),
  resizeHandler: Ember.computed(function() {
    return jQuery.proxy(this.handleWindowResize, this);
  }).property(),
  handleWindowResize: function(event) {
    if (!this.get('resizing')) {
      this.set('resizing', true);
      if (typeof this.onResizeStart === "function") {
        this.onResizeStart(event);
      }
    }
    if (typeof this.onResize === "function") {
      this.onResize(event);
    }
    return this.get('debounceResizeEnd')(event);
  },
  didInsertElement: function() {
    this._super();
    return $(window).bind('resize', this.get("resizeHandler"));
  },
  willDestroy: function() {
    $(window).unbind('resize', this.get("resizeHandler"));
    return this._super();
  }
});

// Generated by CoffeeScript 1.7.1
Ember.ScrollHandlerMixin = Ember.Mixin.create({
  onScroll: Ember.K,
  didInsertElement: function() {
    this._super();
    return this.$().bind('scroll', (function(_this) {
      return function(event) {
        return Ember.run(_this, _this.onScroll, event);
      };
    })(this));
  },
  willDestroy: function() {
    var $element;
    $element = this.$();
    if ($element && $element.unbind) {
      $element.unbind('scroll');
    }
    return this._super();
  }
});

// Generated by CoffeeScript 1.7.1
Ember.StyleBindingsMixin = Ember.Mixin.create({
  isStyleBindings: true,
  init: function() {
    this.applyStyleBindings();
    return this._super();
  },
  concatenatedProperties: ['styleBindings'],
  attributeBindings: ['style'],
  unitType: 'px',
  createStyleString: function(styleName, property) {
    var value;
    value = this.get(property);
    if (value == null) {
      return;
    }
    return this.makeStyleProperty(styleName, value);
  },
  makeStyleProperty: function(styleName, value) {
    if (Ember.typeOf(value) === 'number') {
      value = value + this.get('unitType');
    }
    return "" + styleName + ":" + value + ";";
  },
  applyStyleBindings: function() {
    var lookup, properties, styleBindings, styleComputed, styles;
    styleBindings = this.styleBindings;
    if (!styleBindings) {
      return;
    }
    lookup = {};
    styleBindings.forEach(function(binding) {
      var property, style, _ref;
      _ref = binding.split(':'), property = _ref[0], style = _ref[1];
      return lookup[style || property] = property;
    });
    styles = Ember.keys(lookup);
    properties = styles.map(function(style) {
      return lookup[style];
    });
    styleComputed = Ember.computed((function(_this) {
      return function() {
        var styleString, styleTokens;
        styleTokens = styles.map(function(style) {
          return _this.createStyleString(style, lookup[style]);
        });
        styleString = styleTokens.join('');
        if (styleString.length !== 0) {
          return styleString;
        }
      };
    })(this));
    styleComputed.property.apply(styleComputed, properties);
    return Ember.defineProperty(this, 'style', styleComputed);
  }
});

// Generated by CoffeeScript 1.7.1

/*
@module emberella
@submodule emberella-views
 */
var Emberella, LIST_ITEM_CLASS, get, set;

Emberella = window.Emberella;

get = Ember.get;

set = Ember.set;

LIST_ITEM_CLASS = 'emberella-list-item-view';


/*
  `Emberella.ListItemView` is an `Ember.View` designed for use as a child
  listing of `Emberella.ListView`.

  This class requires the very handy `Ember.StyleBindingsMixin` that is
  packaged with
  [Ember TableView](https://github.com/Addepar/ember-table/ "Ember TableView")

  @class ListItemView
  @namespace Emberella
  @extends Emberella.View
  @uses Ember.StyleBindingsMixin
 */

Emberella.ListItemView = Emberella.View.extend(Ember.StyleBindingsMixin, {

  /*
    Add the class name `emberella-list-item-view`.
  
    @property classNames
    @type Array
    @default ['emberella-list-item-view']
   */
  classNames: [LIST_ITEM_CLASS],

  /*
    Adds a `loading` class to the listing element if its content isn't loaded.
  
    @property classNameBindings
    @type Array
    @default ['isLoaded::loading']
   */
  classNameBindings: ['fluctuateListingClass', 'isLoaded::loading'],

  /*
    Loading state of view. Typically bound to the `isLoaded` property of the
    listing's content.
  
    @property isLoaded
    @type Boolean
   */
  isLoadedBinding: 'content.isLoaded',

  /*
    Defines an array of properties to transform into styles on the listing's
    DOM element.
  
    Functionality provided by `Ember.StyleBindingsMixin`.
  
    @property styleBindings
    @type Array
    @default ['top', 'display', 'position', 'height']
   */
  styleBindings: ['top', 'display', 'position', 'height', 'pointer-events'],

  /*
    In pixels, the height of each listing. Typically, this value is provided
    by the `rowHeight` property of the parent `Emberella.ListView`.
  
    @property rowHeight
    @type Integer
   */
  rowHeightBinding: 'parentView.rowHeight',

  /*
    Give each child listing an additional class name based on the child's
    content index.
  
    For example, setting this property to 2 will cause listings to alternate
    between a class containing 0 or 1. (contentIndex % 2)
  
    @property fluctuateListing
    @type Integer
    @default 2
   */
  fluctuateListing: 2,

  /*
    The seed for the fluctuated class name.
  
    For example, setting this property to `item-listing` would result in class
    names like `item-listing-0` and `item-listing-1`.
  
    @property fluctuateListingPrefix
    @type String
    @default 'emberella-list-item-view'
   */
  fluctuateListingPrefix: LIST_ITEM_CLASS,
  "pointer-events": Ember.computed(function() {
    if (get(this, 'parentView.isScrolling')) {
      return 'none';
    } else {
      return void 0;
    }
  }).property('parentView.isScrolling'),

  /*
    Set `absolute` positioning for each listing.
  
    @property position
    @type String
    @default 'absolute'
   */
  position: Ember.computed(function() {
    return 'absolute';
  }).property(),

  /*
    In pixels, calculate the distance from the top this listing should be
    positioned within the scrolling list.
  
    @property top
    @type Integer
   */
  top: Ember.computed(function() {
    return get(this, 'contentIndex') * get(this, 'rowHeight');
  }).property('contentIndex', 'rowHeight'),

  /*
    Additional class name for this listing.
  
    @property fluctuateListingClass
    @type String
   */
  fluctuateListingClass: Ember.computed(function() {
    var contentIndex, fluctuateListing, fluctuateListingPrefix;
    contentIndex = get(this, 'contentIndex');
    fluctuateListing = parseInt(get(this, 'fluctuateListing'), 10);
    fluctuateListingPrefix = get(this, 'fluctuateListingPrefix');
    if (!(fluctuateListing && fluctuateListing > 0)) {
      return '';
    }
    return [fluctuateListingPrefix, contentIndex % fluctuateListing].join('-');
  }).property('contentIndex', 'fluctuateListing', 'fluctuateListingPrefix'),

  /*
    In pixels, the height of this listing.
  
    @property height
    @type Integer
   */
  height: Ember.computed(function() {
    return +get(this, 'rowHeight');
  }).property('rowHeight'),

  /*
    The display property for this listing 'none' or no value.
  
    Used to hide listings with null or undefined content.
  
    @property display
    @type String
   */
  display: Ember.computed(function() {
    if (!get(this, 'content')) {
      return 'none';
    }
  }).property('content'),

  /*
    Called before destruction of the view object.
  
    @method willDestroy
   */
  willDestroy: function() {
    set(this, 'content', null);
    return this._super();
  },

  /*
    Called after new content assigned to this listing. Override this method to
    inject special data processing or behavior.
  
    @method prepareContent
    @param {Integer} contentIndex
    @param {Boolean} dontFetch
   */
  prepareContent: Ember.K,

  /*
    Called before new content assigned to this listing. Override this method to
    inject special data processing or behavior.
  
    @method teardownContent
    @param {Integer} contentIndex
    @param {Boolean} dontFetch
   */
  teardownContent: Ember.K
});

// Generated by CoffeeScript 1.7.1

/*
@module emberella
@submodule emberella-views
 */
var Emberella, get, set;

Emberella = window.Emberella;

get = Ember.get;

set = Ember.set;


/*
  `Emberella.ListView` is an `Ember.View` descendent designed to incrementally
  (or "lazily") display large lists without sacrificing performance.

  `Emberella.ListView` was developed to address the specific needs for a
  handful of internal web tools within our organization. It borrows heavily
  from
  [Ember ListView](https://github.com/emberjs/list-view/ "Ember ListView")
  and
  [Ember TableView](https://github.com/Addepar/ember-table/ "Ember TableView").

  It is known to work on Safari and Chrome for OS X, but may also work on
  other desktop browsers as well.

  `Emberella.ListView` works by recycling a small number of
  `Emberella.ListItemView`s. For example, given a list of 10,000 items, rather
  than render 10,000 `Ember.View`s, `Emberella.ListView` will create only
  enough listings to fill the space that is visible to the user. As the user
  scrolls, individual listings are repositioned and provided corresponding data
  to display. This strategy creates the illusion of a large scrolling list
  using a smaller number of view objects and DOM nodes to provide a higher
  performance user experience.

   *# Emberella.ListView vs Ember.ListView vs Ember.TableView

  Each of these views offer some features and functionality not provided by
  the other two. In the future, features available in `Emberella.ListView`
  should be added to one or both of those open source projects. Some features
  offered by `Emberella.ListView`:

  1. The ability to specify some number of additional rows to render above and
  below the visible area. In cases where the data loads asynchronously, a
  handful of "bonus" rows "off stage" can boost perceived performance.
  2. The option to wait for scrolling to stop before fetching data. As a result
  async requests are only created when it appears the user has held the same
  scroll position for some configurable amount of time. This reduces network
  traffic for fetching data the user scrolled past but didn't stop to look at.
  Somewhat counter-intuitively, this slight delay boosts perceived performance
  by keeping network resources available even if the user scrolls a long ways
  through the listing.
  3. Support for fluid layout. The `Emberella.ListView` can add and remove
  listing views if the user or application resizes the window or listing
  element.

  @class ListView
  @namespace Emberella
  @extends Emberella.CollectionView
  @uses Ember.ScrollHandlerMixin
  @uses Ember.ResizeHandler
 */

Emberella.ListView = Emberella.CollectionView.extend(Ember.ScrollHandlerMixin, Ember.ResizeHandler, {

  /*
    Add the class name `emberella-list-view`.
  
    @property classNames
    @type Array
    @default ['emberella-list-view']
   */
  classNames: ['emberella-list-view'],

  /*
    Specify the view class for each item listing. This view must be an instance
    of `Emberella.ListItemView` or otherwise fully implement the content
    recycling and re-positioning necessary for this incremental list view to
    function as expected.
  
    @property itemViewClass
    @type Ember.View
    @default Emberella.ListItemView
   */
  itemViewClass: Emberella.ListItemView,

  /*
    List view's current scrolling state. True while scroll top is changing,
    false otherwise.
  
    @property isScrolling
    @type Boolean
    @default false
   */
  isScrolling: false,

  /*
    The current scroll position of the list.
  
    @property scrollTop
    @type Integer
    @default 0
   */
  scrollTop: 0,

  /*
    The height in pixels of each list item.
  
    @property rowHeight
    @type Integer
    @default 50
   */
  rowHeight: 50,

  /*
    A multiplier to calculate the number of extra rows to render above and
    below the portion of the list currently visible to the user.
  
    For example, if 10 rows are visible and `visibilityBuffer` is `0.2`,
    then 2 (10 * 0.2) bonus rows will be rendered above and below the
    "stage." This potentially allows data fetching to commence just a
    little before listings become visible.
  
    @property visibilityBuffer
    @type Number
    @default 0.2
   */
  visibilityBuffer: 0.2,

  /*
    The number of milliseconds to wait between geometry recalculations as
    the user resizes the browser window.
  
    @property resizeThrottle
    @type Integer
    @default 100
   */
  resizeThrottle: 100,

  /*
    The number of milliseconds to wait after the most recent scrolling event
    before initiating any data fetching activity.
  
    This only applies to data that appears stale or is not yet loaded in the
    browser.
  
    @property loadDelay
    @type Integer
    @default 200
   */
  loadDelay: 200,

  /*
    The number of milliseconds scrolling animations will take to complete.
  
    A value of 0 or less will disable scrolling animations entirely.
  
    @property scrollDuration
    @type Integer
    @default 100
   */
  scrollDuration: 100,

  /*
    The width of the listing in pixels. The default behavior supports fluid
    layout. To set a fixed width, extend `Emberella.ListView` and specify an
    integer value for the `width` property.
  
    @property width
    @type Integer
   */
  width: Ember.computed.alias('_width'),

  /*
    The height of the listing in pixels. The default behavior supports fluid
    layout. To set a fixed height, extend `Emberella.ListView` and specify an
    integer value for the `height` property.
  
    @property height
    @type Integer
   */
  height: Ember.computed.alias('_height'),
  init: function() {
    var ret;
    ret = this._super();
    this._renderList();
    return ret;
  },

  /*
    A computed property that indicates the height of the scrollable content.
    Typically calculated by multiplying the length of the content and the
    row height.
  
    @property totalHeight
   */
  totalHeight: Ember.computed(function() {
    var contentLength, totalHeight;
    contentLength = parseInt(get(this, 'content.length'), 10) || 0;
    totalHeight = contentLength * get(this, 'rowHeight');
    return totalHeight;
  }).property('content.length', 'rowHeight'),

  /*
    A computed property that indicates the index of the row closest to the
    top of the list that is (or should be) rendered.
  
    @property startingIndex
    @type Integer
   */
  startingIndex: Ember.computed(function() {
    var idx;
    idx = Math.floor(get(this, 'scrollTop') / get(this, 'rowHeight')) - get(this, 'additionalRows');
    if (idx > 0) {
      return idx;
    } else {
      return 0;
    }
  }).property('scrollTop', 'rowHeight', 'additionalRows'),

  /*
    A computed property that indicates the number of rows that should be
    currently visible to the user. One additional row will always be
    added to ensure row views aren't recycled until they've moved offstage.
  
    @property rows
   */
  rows: Ember.computed(function() {
    var rowCount;
    rowCount = get(this, 'height') / get(this, 'rowHeight');
    return Math.ceil(rowCount) + 1;
  }).property('height', 'rowHeight', 'totalHeight'),

  /*
    A computed property that indicates the number of extra rows to render above
    and below the stage.
  
    @property additionalRows
   */
  additionalRows: Ember.computed(function() {
    return Math.ceil(get(this, 'rows') * get(this, 'visibilityBuffer'));
  }).property('rows', 'visibilityBuffer'),

  /*
    A computed property that indicates the number of rows to render.
  
    @property visibleRows
   */
  visibleRows: Ember.computed(function() {
    return +get(this, 'rows') + (2 * get(this, 'additionalRows'));
  }).property('rows', 'additionalRows'),

  /*
    A computed property that returns a throttled layout recalculation function.
  
    @property throttledOnResize
   */
  throttledOnResize: Ember.computed(function() {
    return Emberella.throttle(((function(_this) {
      return function() {
        return _this._recalculateDimensions();
      };
    })(this)), get(this, 'resizeThrottle'));
  }).property('resizeThrottle'),

  /*
    A computed property that returns a debounced scroll handling function
  
    @property debouncedOnScroll
   */
  debouncedOnScroll: Ember.computed(function() {
    return Emberella.debounce(((function(_this) {
      return function() {
        if (!(get(_this, 'isDestroyed') || get(_this, 'isDestroying'))) {
          return set(_this, 'isScrolling', false);
        }
      };
    })(this)), 30);
  }),

  /*
    Calls the throttled layout recalculation method.
  
    @method adjustLayout
   */
  adjustLayout: function() {
    return get(this, 'throttledOnResize')();
  },

  /*
    Check if an object is already loaded at a specified index.
  
    @method isObjectAt
    @param {Integer} idx The index to check for an object
    @return {Boolean} Returns true if object found at index provided
   */
  isObjectAt: function(idx) {
    var content;
    content = get(this, 'content');
    if (content == null) {
      return false;
    }
    if (content.isObjectAt) {
      return !!(content.isObjectAt(idx));
    } else if (content.objectAtContent) {
      return !!(content.objectAtContent(idx));
    } else {
      return !!(content.objectAt(idx));
    }
  },

  /*
    Scroll to the specified position given in pixels.
  
    To help users follow scrolling activity, this method includes a quick
    animation courtesy of jQuery `animate` if available.
  
    @method scrollTo
    @param {Integer} scrollTop New scroll location in pixels
    @param {Boolean} disableAnimate Shut off animated scroll if true
    @chainable
   */
  scrollTo: function(scrollTop, disableAnimate) {
    var $element, scrollDuration;
    if (disableAnimate == null) {
      disableAnimate = false;
    }
    scrollTop = parseInt(scrollTop, 10) || 0;
    scrollTop = Math.min(scrollTop, get(this, 'totalHeight') - get(this, 'height'));
    scrollDuration = parseInt(get(this, 'scrollDuration'), 10) || 0;
    $element = this.$();
    if (($element != null) && ($element.stop != null) && $element.animate && scrollDuration > 0 && !disableAnimate) {
      $element.stop(true, true).animate({
        scrollTop: scrollTop
      }, scrollDuration);
    } else {
      get(this, 'element').scrollTop = scrollTop;
      set(this, 'scrollTop', scrollTop);
    }
    return this;
  },

  /*
    Scroll to the item at the specified index.
  
    The item can be scrolled into view with its bottom edge aligned to the
    bottom of the viewable area (default) or with its top edge aligned to the
    top of the viewable area.
  
    If the item is already fully visible, this method will have no effect.
  
    @method scrollToItem
    @param {Integer} idx Index of listing to scroll to
    @param {Boolean} alignToFirst Item scrolls to top or bottom of stage
    @chainable
   */
  scrollToItem: function(idx, alignToFirst) {
    var contentLength, scrollPosition;
    if (alignToFirst == null) {
      alignToFirst = false;
    }
    if (this.itemFullyVisible(idx)) {
      return this;
    }
    idx = parseInt(idx, 10) || 0;
    contentLength = get(this, 'content.length');
    idx = Math.min(idx, contentLength);
    scrollPosition = this.computeItemScrollPosition(idx);
    if (!alignToFirst) {
      scrollPosition = scrollPosition - get(this, 'height') + get(this, 'rowHeight');
    }
    return this.scrollTo(scrollPosition);
  },

  /*
    Scroll down or up a "page."
  
    @method scrollPage
    @param {Boolean} up Scroll up one "page" if true
    @chainable
   */
  scrollPage: function(up) {
    var delta, height, scrollTop;
    if (up == null) {
      up = false;
    }
    scrollTop = get(this, 'scrollTop');
    height = get(this, 'height');
    delta = Math.floor(height * 0.94);
    if (up) {
      delta = -1 * delta;
    }
    return this.scrollTo(scrollTop + delta);
  },

  /*
    Scroll one "page" up
  
    @method scrollPageUp
    @chainable
   */
  scrollPageUp: function() {
    return this.scrollPage(true);
  },

  /*
    Scroll one "page" down
  
    @method scrollPageDown
    @chainable
   */
  scrollPageDown: function() {
    return this.scrollPage(false);
  },

  /*
    Scroll instantly to the top of the listing.
  
    @method scrollToTop
    @chainable
   */
  scrollToTop: function() {
    return this.scrollTo(0, true);
  },

  /*
    Scroll instantly to the end of the listing.
  
    @method scrollToBottom
    @chainable
   */
  scrollToBottom: function() {
    return this.scrollTo(get(this, 'totalHeight'), true);
  },

  /*
    Calculates the specified item's scroll position from the top of the
    listing. Scrolling to the result should align the top of the item with the
    top of the viewable area.
  
    @method computeItemScrollPosition
    @param {Integer} idx Index to calculate a scroll position for
    @return {Integer}
   */
  computeItemScrollPosition: function(idx) {
    return (parseInt(idx, 10) || 0) * get(this, 'rowHeight');
  },

  /*
    Calculates the specified item's scroll position from the top of the
    listing. Scrolling to the result should align the top of the item with the
    top of the viewable area.
  
    @method itemFullyVisible
    @param {Integer} idx Index to check for visibility
    @return {Boolean}
   */
  itemFullyVisible: function(idx) {
    var itemBottom, itemTop, stageBottom, stageTop;
    idx = parseInt(idx, 10) || 0;
    stageTop = get(this, 'scrollTop');
    stageBottom = stageTop + get(this, 'height');
    itemTop = this.computeItemScrollPosition(idx);
    itemBottom = itemTop + get(this, 'rowHeight');
    return !!(itemTop >= stageTop && itemBottom <= stageBottom);
  },

  /*
    Calculates the number of list items to render.
  
    @method numberOfVisibleItems
    @return {Integer}
   */
  numberOfVisibleItems: function() {
    return Math.min(get(this, 'visibleRows'), get(this, 'content.length'));
  },

  /*
    Override standard collection view behavior.
  
    @method arrayWillChange
   */
  arrayWillChange: Ember.K,

  /*
    Override standard collection view behavior.
  
    @method arrayDidChange
   */
  arrayDidChange: function(content, start, removed, added) {
    return this._updateChildViews();
  },

  /*
    Adjust list view layout after being added to the DOM. Override this
    function to do any set up that requires an element in the document body.
  
    @event didInsertElement
   */
  didInsertElement: function() {
    this._super();
    return this.adjustLayout();
  },

  /*
    Called before destruction of the view.
  
    @method willDestroy
   */
  willDestroy: function() {
    this.destroyAllChildren();
    return this._super();
  },

  /*
    Adjust list view layout after window resized.
  
    @event onResize
   */
  onResize: function(e) {
    return this.adjustLayout();
  },

  /*
    Update scrollTop property with value reported by the DOM event.
  
    @event onScroll
   */
  onScroll: function(e) {
    set(this, 'isScrolling', true);
    set(this, 'scrollTop', e.target.scrollTop);
    return get(this, 'debouncedOnScroll')();
  },

  /*
    Called when scrolling reaches the top of the listing.
  
    @event didScrollToTop
   */
  didScrollToTop: Ember.K,

  /*
    Called when scrolling reaches the end of the listing.
  
    @event didScrollToBottom
   */
  didScrollToBottom: Ember.K,

  /*
    Called when the number of visible listings changes.
  
    Triggered with a single argument: the number of items this listing view
    will attempt to render.
  
    Useful for alerting the controller how many items should be fetched from
    the server.
  
    @event visibleItemsDidChange
   */
  visibleItemsDidChange: Ember.K,

  /*
    @private
  
    Renders the list items and inserts an element to establish the scrolling
    height.
  
    @method _renderList
   */
  _renderList: function() {
    this._appendScrollingView();
    return Ember.run.later(this, function() {
      return this._updateChildViews();
    }, 1);
  },

  /*
    @private
  
    Resets the list rendering.
  
    @method _rerenderList
   */
  _rerenderList: function() {
    this.destroyAllChildren();
    return this._renderList();
  },

  /*
    @private
  
    Inject a really tall element into the listing to "prop it open."
  
    @method _appendScrollingView
   */
  _appendScrollingView: function() {
    return this.pushObject(this._createScrollingView());
  },

  /*
    @private
  
    Create a really tall element that establishes the scrolling height for this
    listing.
  
    @method _createScrollingView
   */
  _createScrollingView: function() {
    var scrollTag;
    scrollTag = Ember.CollectionView.CONTAINER_MAP[get(this, 'tagName')];
    return Ember.View.createWithMixins(Ember.StyleBindingsMixin, {
      tagName: scrollTag,
      styleBindings: ['height', 'width'],
      heightBinding: 'parentView.totalHeight',
      width: 1
    });
  },

  /*
    @private
  
    Provide updated data and positioning to each child listing as the scroll
    position changes.
  
    In short: this is the listing view recycling center.
  
    @method _updateChildViews
    @return null
   */
  _updateChildViews: Ember.observer(function() {
    var childView, childViews, childViewsLength, contentLength, delta, emptyView, endingIndex, i, idxBottom, isClass, itemViewClass, startingIndex, visibleItems, _i, _j, _k, _ref;
    if (get(this, 'isDestroyed')) {
      return;
    }
    emptyView = get(this, 'emptyView');
    if (emptyView && emptyView instanceof Ember.View) {
      emptyView.removeFromParent();
    }
    itemViewClass = get(this, 'itemViewClass');
    if (typeof itemViewClass === 'string') {
      itemViewClass = get(itemViewClass);
    }
    contentLength = get(this, 'content.length');
    childViews = this;
    childViewsLength = Math.max(0, get(this, 'length') - 1);
    visibleItems = this.numberOfVisibleItems();
    delta = visibleItems - childViewsLength;
    startingIndex = this._startingIndex();
    endingIndex = startingIndex + visibleItems;
    idxBottom = this._indexOfBottomRow() || childViewsLength;
    if (contentLength > 0) {
      if (delta !== 0) {
        for (i = _i = 0; 0 <= delta ? _i < delta : _i > delta; i = 0 <= delta ? ++_i : --_i) {
          if (delta > 0) {
            this.insertAt(idxBottom + i, this.createChildView(itemViewClass));
          } else {
            if ((_ref = this.objectAt(idxBottom + i)) != null) {
              _ref.removeFromParent().destroy();
            }
          }
        }
        childViewsLength = visibleItems;
      }
      for (i = _j = startingIndex; startingIndex <= endingIndex ? _j < endingIndex : _j > endingIndex; i = startingIndex <= endingIndex ? ++_j : --_j) {
        childView = childViews.objectAt(i % childViewsLength);
        this._reuseChildForContentIndex(childView, i);
      }
    } else {
      for (i = _k = 0; 0 <= childViewsLength ? _k < childViewsLength : _k > childViewsLength; i = 0 <= childViewsLength ? ++_k : --_k) {
        childView = childViews.objectAt(i);
        if (childView) {
          this._reuseChildForContentIndex(childView, i);
        }
      }
      if (!emptyView) {
        return;
      }
      isClass = Ember.CoreView.detect(emptyView);
      emptyView = this.createChildView(emptyView);
      set(this, 'emptyView', emptyView);
      if (isClass) {
        this._createdEmptyView = emptyView;
      }
      this.unshiftObject(emptyView);
    }
    return null;
  }, 'startingIndex'),

  /*
    @private
  
    Recycle a child listing with data from a specified index.
  
    If content is available at the specified index, it will be injected into
    the listing immediately. Otherwise, the listing will wait the number of
    milliseconds defined in the `loadDelay` property. If the scroll position
    has not changed during the delay, the list view will request the data be
    fetched.
  
    @method _reuseChildForContentIndex
    @param {Emberella.ListItemView} childView The listing to update
    @param {Integer} contentIndex
    @return null
   */
  _reuseChildForContentIndex: function(childView, contentIndex) {
    var currentStartingIndex;
    if (childView == null) {
      return;
    }
    if (get(childView, 'isDestroyed')) {
      return;
    }
    currentStartingIndex = this._startingIndex();
    this._finalizeReuseChildForContentIndex(childView, contentIndex, true);
    if (!this.isObjectAt(contentIndex)) {
      Ember.run.later(this, function() {
        if (currentStartingIndex === this._startingIndex()) {
          return this._finalizeReuseChildForContentIndex(childView, contentIndex);
        }
      }, get(this, 'loadDelay'));
    }
    return null;
  },

  /*
    @private
  
    Complete recycle process a child listing with data from a specified index.
  
    In attempting to request data from the attached controller, the list view
    will pass an additional `dontFetch` parameter if content should not be
    retrieved from the persistence layer for this listing.
  
    @method _finalizeReuseChildForContentIndex
    @param {Emberella.ListItemView} childView The listing to update
    @param {Integer} contentIndex
    @param {Boolean} dontFetch
    @return null
   */
  _finalizeReuseChildForContentIndex: function(childView, contentIndex, dontFetch) {
    var content, contentLength, currentContent, newContent;
    if (dontFetch == null) {
      dontFetch = false;
    }
    if (get(childView, 'isDestroyed')) {
      return;
    }
    content = get(this, 'content');
    contentLength = get(this, 'content.length');
    currentContent = get(childView, 'content');
    newContent = contentIndex < contentLength ? content.objectAt(contentIndex, dontFetch) : null;
    if (currentContent === newContent) {
      return;
    }
    if ((childView != null ? childView.teardownContent : void 0) != null) {
      childView.teardownContent(contentIndex, dontFetch);
    }
    set(childView, 'contentIndex', contentIndex);
    set(childView, 'content', newContent);
    if ((childView != null ? childView.prepareContent : void 0) != null) {
      childView.prepareContent(contentIndex, dontFetch);
    }
    return null;
  },

  /*
    @private
  
    Return the current `startingIndex` property.
  
    @method _startingIndex
    @return Integer
   */
  _startingIndex: function() {
    return get(this, 'startingIndex');
  },

  /*
    @private
  
    The bottom row is the rendered listing view farthest from the top of the
    scrolling list.
  
    The intent of this computation is to allow new listings to be inserted
    below the bottom-most "visible" row and reduce the need for completely
    recycling every listing when new, visible items are added for any reason
    (e.g. new records, window resized)
  
    @method _indexOfBottomRow
    @return Integer
   */
  _indexOfBottomRow: function() {
    var childView, childViews, childViewsLength, i, previousTop, result, top, _i, _ref;
    result = 0;
    childViews = this;
    childViewsLength = get(this, 'length') - 1;
    previousTop = 0;
    if (childViewsLength <= 0) {
      return result;
    }
    for (i = _i = 0; 0 <= childViewsLength ? _i < childViewsLength : _i > childViewsLength; i = 0 <= childViewsLength ? ++_i : --_i) {
      childView = childViews.objectAt(i);
      top = (_ref = childView.get('top')) != null ? _ref : 0;
      if (top >= previousTop) {
        result = i;
        previousTop = top;
      } else {
        return result;
      }
    }
    return result;
  },

  /*
    @private
  
    Update both the height and width properties of this view based on its
    current state in the DOM.
  
    @method _recalculateDimensions
   */
  _recalculateDimensions: function() {
    this._recalculateWidth();
    return this._recalculateHeight();
  },

  /*
    @private
  
    Update the width property of this view based on its current state in
    the DOM.
  
    @method _recalculateWidth
   */
  _recalculateWidth: function() {
    if (get(this, 'isDestroyed') || get(this, 'isDestroying')) {
      return;
    }
    return this.set('_width', this.get('state') === 'inDOM' ? +this.$().width() : window.innerWidth);
  },

  /*
    @private
  
    Update the height property of this view based on its current state in
    the DOM.
  
    @method _recalculateHeight
   */
  _recalculateHeight: function() {
    if (get(this, 'isDestroyed') || get(this, 'isDestroying')) {
      return;
    }
    return this.set('_height', this.get('state') === 'inDOM' ? +this.$().height() : window.innerHeight);
  },

  /*
    @private
  
    Handle a complete change of content.
  
    @method _contentDidChange
   */
  _contentDidChange: Ember.observer(function() {
    this._super();
    if (get(this, 'state') === 'inDOM') {
      return this._rerenderList();
    }
  }, 'content'),

  /*
    @private
  
    Trigger event when scroll position reaches the beginning or end.
  
    @method _scrollTopDidChange
   */
  _scrollTopDidChange: Ember.observer(function() {
    var scrollTop;
    scrollTop = get(this, 'scrollTop');
    if (scrollTop <= 0) {
      return this.trigger('didScrollToTop');
    } else if (scrollTop >= (get(this, 'totalHeight') - get(this, 'height'))) {
      return this.trigger('didScrollToBottom');
    }
  }, 'scrollTop'),

  /*
    @private
  
    Trigger event when the number of visible items appears to have changed.
  
    @method _visibleItemsDidChange
   */
  _visibleItemsDidChange: Ember.observer(function() {
    return this.trigger('visibleItemsDidChange', this.numberOfVisibleItems() || 0);
  }, 'visibleRows')
});